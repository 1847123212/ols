= LogicSniffer =

Some documentation on the LogicSniffer client.

== Architecture ==

The client will be entirely OSGi-based. Reasons to chose for this is that all projects 
are loosely coupled and can be upgraded individually. In addition, OSGi provides the
ability to load/unload native libraries for the correct operating system out of the box. 

A description of the current projects is given in the following paragraphs.

=== RXTX ===

Provides the serial I/O routines for communicating with serial devices, such as the 
LogicSniffer. It integrates the native libraries for various operating systems. 
Currently, the following operating systems are supported:

* Windows 32/64 bits;
* Linux 32/64 bits;
* Mac OSX 32/64 bits.

=== API ===

Provides the common API (maybe "common API" would be a better name?) shared between the 
client, tools and devices. This project does nothing on its own but provides some common
code for the rest of the projects.

The idea is to have only interfaces in the API-project, but this is currently not the 
case. For example the AnnotatedData implementation is used by several other projects,
and is a concrete class instead of an interface. To really solve this, one would need an
additional project that provides common implementations. 

=== Client ===

Provides the actual UI of the client and forms the "glue" between devices, tools and UI.
The client project is more or less an empty "shell" that allows devices and tools to be 
added dynamically. The UI is entirely Swing based.

=== Devices ===

Provides support for the actual devices, such as the LogicSniffer and a testing device. 
A device contains everything to actually work with the device, from low-level 
communications to configuration UI and interfacing logic with the rest of the client.

=== Tools ===

Provides analysis, measurement and other tools that can provide additional information 
about captured data. Most of the current tools do some "heavy" processing of data, which
should be done in the background to keep the UI responsive. To make writing such tools
easier, a "base" tool is provided which provides most of the boilerplate code. 

=== Exports ===

Provides the export functionality from the diagram to various output formats. The 
exporters get access to the complete diagram, which can result in a ''very'' memory
consuming export. No limitations are enforced from the platform.

=== Runner ===

Provides a small "bootstrap" for the OSGi container. This project is the only non-OSGi 
project. It provides the only "main" method in all projects and this main should start
the OSGi container with some predefined configuration and let the OSGi container do the
remainder of the work. Currently, Felix 3.0 is used as OSGi container.

=== Logging ===

Provides a logging "bridge" for Java's native logging functionality and OSGi Logging 
service. It allows classes to log using Java's native logging functionality 
(java.util.logging) which will be redirected to a OSGi log service under water. 
 
=== Util ===

Provides some common utilities that are shared among all other projects. 

== OLS data file format ==

For storing captured data to files, the OLS uses the data format as used by the original
sump client. The format is plain text, and rather easy to parse.

If a line starts with a semicolon (;), it will be regarded as a header, or metadata. 
These headers contain information about the actual sample data, such as sample rate, 
capture length, and so on. If a line does '''not''' start with a semicolon, but contains 
only ''hexadecimal digits'' and ''one at-sign'' (@), it will be regarded as sample data.
All other lines are to be ignored.

=== Headers ===

Headers start with a semicolon and are always a single line (so, terminated with carriage-
return and/or line-feed). Headers contain of a key-value pair separated by a colon (:). 
The format of a header is:

  ;<name>: <value>

In which the ''<name>'' is a predefined header name (case sensitive!), and the ''<value>'' 
an arbritary value for that particular header. 

The following headers are understood by the current client:

* ''Size'': (Integer, mandatory) defines the absolute number of samples the file contains;
* ''Rate'': (Integer, mandatory) defines the original sample rate, in Hertz, at which the data was taken;
* ''Channels'': (Integer, mandatory) defines the number of channels in the sample data, should be 8, 16, 24 or 32;
* ''EnabledChannels'': (Integer, optional) defines which channel groups are enabled (unused at the moment);
* ''Compressed'': (Boolean, mandatory) should always be set to '''true''';
* ''AbsoluteLength'': (Integer, mandatory) defines the total number of samples taken. Can be used together with the sample rate to determine the total capture time;
* ''CursorEnabled'': (Boolean, optional) defines whether or not cursors are to be enabled;
* ''Cursor0''..''Cursor9'': (Long integer, optional) defines the time values of the individual cursors (up to ten).

Integer values are expected to be ''32-bit signed values'', while Long integers are expected to be 
''64-bit signed values''. Booleans are expected as ''true'' or ''false'' string values.  

=== Sample data ===

Sample data are always a single line (similar as headers) consisting of hexadecimal digits
(0-9, a-f, A-F) and an at-sign (@). The format of sample data is:

  <sample value>@<sample number>

In which the ''<sample number>'' is the '''decimal''' (base 10) representation of the absolute sample 
number, and ''<sample value>'' the '''hexadecimal''' (base 16) representation of the sample value itself.

Note that the ''Size'' header '''must''' match the total count of sample data.

== To do ==

# support easy/easier upgrade procedure;
# support OLS-device profiles for BP, regular OLS and SUMP;
# make the tools aware of the device capabilities (5 channels for BP iso 32, etc.);
# show timing measurements between edges, or from rising to rising or falling to falling edges;
# configurable colors would be nice, so that the user can set them to match the probes;
# integrate analysis reports & annotations into one and make it configurable which one is shown/used;
# make the annotated data configurable regarding the displayed text and colors;
# make distinction between decoding tools and other tools;
# provide easier access to analysis tools;
# analysis protocol results synopsis (client: <bla bla>, master: <bla bla>, client ...);
# support reordering of channels with DnD;
# support overlay of signals, to view differences between two, or more signal captures;
# add option to auto-center captured signal on trigger moment;

